<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet", href="style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <title>OOPs Glossary Part2</title>
</head>
    <body>
    <header class="main-header">
        <nav class="nav main-nav">
            <ul>
                <li class="nav-item ">
                    <a class="nav-link " aria-current="page" href="OOPS_Glossary.html">OOP Glossary</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="OOPs_Glossary_Part2.html">OOP Glossary Part2</a>
                </li>
            </ul>
        </nav>
        <h1 class="Title Title-Large">OOPs Glossary Continued...</h1>
    </header>
    <section class="content-section">
        <img class="image_new" src="img\fixture.png" alt="fixture">
        <h2 class="section-header"></h2>
        <p>In testing, a fixture provides a defined, reliable and consistent context for the tests. This could include environment
            (for example a database configured with known parameters) or content (such as a dataset). Fixtures define the steps and
            data that constitute the arrangement phase of a test (see Anatomy of a test). In pytest, they are functions you define that serve this purpose. They can also be used to define a test’s act phase; this is a powerful technique for designing more complex tests.
            The services, state, or other operating environments set up by fixtures are accessed by test functions through arguments.
            For each fixture used by a test function there is typically a parameter (named after the fixture) in the test function’s
            definition. Ex pytest.fixture, clear_history is one method which is passed as reference to other test methods of the
            calculator_test class for performing clear history operation after every calculator test method.</p>
    </section>

    <section class="content-section">
        <img class="image_new" src="https://pynative.com/wp-content/uploads/2021/08/python_class_method_vs_static_method_vs_instance_method.png">
        <h2 class="section-header"></h2>
        <p>Static methods in Python are extremely similar to python class level methods, the difference being
            that a static method is bound to a class rather than the objects for that class. This means that a static method can be
            called without an object for that class. This also means that static methods cannot modify the state of an object as they
            are not bound to it. def get_history(), def get_result_of_first_calculation(), def clear_history() are few such examples of
            the static methods for the class.</p>
        <p>A class method is a method which is bound to the class and not the object of the class. They have the access to the state of
            the class as it takes a class parameter that points to the class and not the object instance. It can modify a class state that
            would apply across all the instances of the class. For example, it can modify a class variable that would be applicable to all
            the instances. Addition, subtraction and Multiplication classes may be one such examples of it.</p>
        <p>A class is a user-defined blueprint or prototype from which objects are created. Classes provide a means of bundling data and
            functionality together. Creating a new class creates a new type of object, allowing new instances of that type to be made.
            Each class instance can have attributes attached to it for maintaining its state. Class instances can also have methods
            (defined by its class) for modifying its state. def __init__(self, value_a, value_b) may be one such example of the instance
            methods</p>
    </section>
    <section class="content-section">
        <img class="image_new" src="https://media.geeksforgeeks.org/wp-content/uploads/20200203095945/Facade-Method.png">
        <h2 class="section-header"></h2>
        <p>Design Patterns is the most essential part of Software
            Engineering, as they provide the general repeatable solution to a commonly occurring problem in software design.
            Ex: Facade Method is a Structural Design pattern that provides a simpler unified interface to a more complex system.
            The word Facade means the face of a building or particularly an outer lying interface of a complex system, consists of
            several sub-systems.</p>
    </section>
    <section class="content-section">
    <img class="image_new" src="https://www.freecodecamp.org/news/content/images/2019/12/property-v2-HD.png">
    <h2 class="section-header"></h2>
    <p>Python property() function returns the object of the property class, and it is used to create property of a class.
        A property may be defined using key word such as @staticmethod for defining the scope of the class as well as the value being
        returned.</p>
    </section>
    <footer class="bottom">
        <a href></a>
    </footer>

    </body>
</html>